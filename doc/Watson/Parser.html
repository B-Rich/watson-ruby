<!DOCTYPE html>
<!--

  Fivefish RDoc Generator
  $Id$

  Authors:
  - Michael Granger <ged@FaerieMUD.org>

 -->
<html lang="en">
<head>
	<title>RDoc Documentation</title>

	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
		<script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<link rel="shortcut icon" href="images/favicon.ico">
	<link rel="apple-touch-icon" href="images/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">

	<link href=".." rel="prefix" />

	<link href="../css/fivefish.min.css" rel="stylesheet" />

	<script src="../js/jquery-1.7.1.min.js" type="text/javascript"
		defer="defer" charset="utf-8"></script>
	<script src="../js/bootstrap.min.js" type="text/javascript"
		defer="defer" charset="utf-8"></script>
	<script src="../js/searchindex.js" type="text/javascript"
		defer="defer" charset="utf-8"></script>
	<script src="../js/fivefish.min.js" type="text/javascript"
		defer="defer" charset="utf-8" onload="initFivefish()"></script>
</head>

<body class="class-page">

	<nav class="navbar navbar-fixed-top">
		<div class="navbar-inner">
			<div class="container">
				<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</a>

				<a class="brand"
					href="../index.html">RDoc Documentation</a>

				<div class="nav-collapse">
					<ul class="nav">
						<li>
							<a href="#"
								class="dropdown-toggle"
								data-dropdown="#class-dropdown">
								Classes
								<b class="caret"></b>
							</a>
						</li>
						<li>
							<a href="#"
								class="dropdown-toggle"
								data-dropdown="#file-dropdown">
								Files
								<b class="caret"></b>
							</a>
						</li>
					</ul>
				</div><!--/.nav-collapse -->
				<span class="pull-right">
					<form class="navbar-search">
						<input type="hidden" id="navbar-search-target" value="" />
						<input type="text" class="search-query" value=""
							placeholder="Method, Class, or Filename" />
					</form>
				</span>
			</div>
		</div>
	</nav>

	<div class="container">
		
		<header class="hero-unit">
			<hgroup>
								  				<h2 class="namespace">Watson::</h2>
				  												<h1 class="class"
					rel="popover"
					data-original-title="In files"
					data-content="lib/watson/parser.rb"
					>Parser</h1>
				</p>
							</hgroup>
			<span class="label">class</span>
		</header>

		<section class="module-relations">
			<dl>
								<dt>Superclass</dt>
								<dd class="superclass">Object</dd>
								
								<dt>Included Modules</dt>
												<dd class="include"><a href="../Watson.html">Watson</a></dd>
												
							</dl>
		</section>

		<section class="description">
			
<p>Dir/File parser class Contains all necessary methods to parse through files
and directories  for specified tags and generate data structure containing
found issues</p>
		</section>

				<section id="5Buntitled-5D" class="documentation-section">
			
		    
						<!-- Constants -->
			<section class="constants-list">
				<header>
					<h3>Constants</h3>
				</header>
				<dl>
									<dt id="DEBUG"><i class="icon-generic"></i>DEBUG</dt>
										<dd class="description"><p>Debug printing for this class</p></dd>
													</dl>
			</section>
			
			
			<!-- Methods -->
						
						<section class="public-methods class-methods methods">
				<header>
					<h3>Public Class Methods</h3>
				</header>

								<a name="method-c-new">anchor</a>
				<div id="method-c-new-doc" class="method">

					<header>
											<i class="icon-generic"></i>
						<span class="method-name">new</span><span 
							class="method-args">(config)</span>
										</header>

					<div class="method-description">
											<p>Initialize the parser with the current watson config</p>					
											<div class="method-source-code" id="new-source">
							<pre class="prettyprint linenums"><code 
								class="language-ruby"><span class="ruby-comment"># File lib/watson/parser.rb, line 20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">config</span>)
<span class="ruby-comment"># [review] - Not sure if passing config here is best way to access it</span>

        <span class="ruby-comment"># Identify method entry</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ self } : #{ __method__ }\n&quot;</span>
        
        <span class="ruby-ivar">@config</span> = <span class="ruby-identifier">config</span>
<span class="ruby-keyword">end</span></code></pre>
						</div>
										</div>

					
									</div>
				
			</section>
			
			
			
			
			
									
						<section class="public-methods instance-methods methods">
				<header>
					<h3>Public Instance Methods</h3>
				</header>

								<a name="method-i-get_comment_type">anchor</a>
				<div id="method-i-get_comment_type-doc" class="method">

					<header>
											<i class="icon-generic"></i>
						<span class="method-name">get_comment_type</span><span 
							class="method-args">(filename)</span>
										</header>

					<div class="method-description">
											<p>Get comment syntax for given file</p>					
											<div class="method-source-code" id="get_comment_type-source">
							<pre class="prettyprint linenums"><code 
								class="language-ruby"><span class="ruby-comment"># File lib/watson/parser.rb, line 352</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_comment_type</span>(<span class="ruby-identifier">filename</span>)

        <span class="ruby-comment"># Identify method entry</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ self } : #{ __method__ }\n&quot;</span>

        <span class="ruby-comment"># Grab the file extension (.something)</span>
        <span class="ruby-comment"># Check to see whether it is recognized and set comment type</span>
        <span class="ruby-comment"># If unrecognized, try to grab the next .something extension</span>
        <span class="ruby-comment"># This is to account for file.cpp.1 or file.cpp.bak, ect</span>

        <span class="ruby-comment"># [review] - Matz style while loop a la http://stackoverflow.com/a/10713963/1604424</span>
        <span class="ruby-comment"># Create _mtch var so we can access it outside of the do loop</span>

        <span class="ruby-identifier">_mtch</span> = <span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-identifier">loop</span> <span class="ruby-keyword">do</span>
                <span class="ruby-identifier">_mtch</span> = <span class="ruby-identifier">filename</span>.<span class="ruby-identifier">match</span>(<span class="ruby-regexp">/(\.(\w+))$/</span>)
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Extension: #{ _mtch }\n&quot;</span>

                <span class="ruby-comment"># Break if we don&#39;t find a match </span>
                <span class="ruby-keyword">break</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">_mtch</span> <span class="ruby-operator">==</span> <span class="ruby-keyword">nil</span>

                <span class="ruby-comment"># Determine file type</span>
                <span class="ruby-keyword">case</span> <span class="ruby-identifier">_mtch</span>[<span class="ruby-value">0</span>]
                <span class="ruby-comment"># C / C++</span>
                <span class="ruby-comment"># [todo] - Add /* style comment</span>
                <span class="ruby-keyword">when</span> <span class="ruby-string">&quot;.cpp&quot;</span>, <span class="ruby-string">&quot;.cc&quot;</span>, <span class="ruby-string">&quot;.c&quot;</span>, <span class="ruby-string">&quot;.hpp&quot;</span>, <span class="ruby-string">&quot;.h&quot;</span>
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;Comment type is: //\n&quot;</span>
                        <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;//&quot;</span>

                <span class="ruby-comment"># Bash / Ruby / Perl</span>
                <span class="ruby-keyword">when</span> <span class="ruby-string">&quot;.sh&quot;</span>, <span class="ruby-string">&quot;.rb&quot;</span>, <span class="ruby-string">&quot;.pl&quot;</span>
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Comment type is: #\n&quot;</span>
                        <span class="ruby-keyword">return</span> <span class="ruby-node">&quot;#&quot;</span>

                <span class="ruby-comment"># Can&#39;t recognize extension, keep looping in case of .bk, .#, ect</span>
                <span class="ruby-keyword">else</span>
                        <span class="ruby-identifier">filename</span> = <span class="ruby-identifier">filename</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/(\.(\w+))$/</span>, <span class="ruby-string">&quot;&quot;</span>)
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Didn&#39;t recognize, searching #{ filename }\n&quot;</span>
                
                <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

        <span class="ruby-comment"># We didn&#39;t find any matches from the filename, return error (0)</span>
        <span class="ruby-comment"># Deal with what default to use in calling method</span>
        <span class="ruby-comment"># [review] - Is Ruby convention to return 1 or 0 (or -1) on failure/error?</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;Couldn&#39;t find any recognized extension type\n&quot;</span>
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> 
        
<span class="ruby-keyword">end</span></code></pre>
						</div>
										</div>

					
									</div>
								<a name="method-i-parse_dir">anchor</a>
				<div id="method-i-parse_dir-doc" class="method">

					<header>
											<i class="icon-generic"></i>
						<span class="method-name">parse_dir</span><span 
							class="method-args">(dir, depth)</span>
										</header>

					<div class="method-description">
											<p>Parse through specified directory and find all subdirs and files</p>					
											<div class="method-source-code" id="parse_dir-source">
							<pre class="prettyprint linenums"><code 
								class="language-ruby"><span class="ruby-comment"># File lib/watson/parser.rb, line 68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">parse_dir</span>(<span class="ruby-identifier">dir</span>, <span class="ruby-identifier">depth</span>)

        <span class="ruby-comment"># Identify method entry</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ self } : #{ __method__ }\n&quot;</span>

        <span class="ruby-comment"># Error check on input</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-constant">Watson</span><span class="ruby-operator">::</span><span class="ruby-constant">FS</span>.<span class="ruby-identifier">check_dir</span>(<span class="ruby-identifier">dir</span>)
                <span class="ruby-identifier">print</span> <span class="ruby-node">&quot;Unable to open #{ dir }, exiting\n&quot;</span>
                <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>
        <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Opened #{ dir } for parsing\n&quot;</span>
        <span class="ruby-keyword">end</span>
        
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Parsing through all files/directories in #{ dir }\n&quot;</span>

        <span class="ruby-comment"># [review] - Shifted away from single Dir.glob loop to separate for dir/file</span>
        <span class="ruby-comment">#                     This duplicates code but is much better for readability</span>
        <span class="ruby-comment">#                     Not sure which is preferred?</span>
        

        <span class="ruby-comment"># Remove leading . or ./</span>
        <span class="ruby-identifier">_glob_dir</span> = <span class="ruby-identifier">dir</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/^\.(\/?)/</span>, <span class="ruby-string">&#39;&#39;</span>)
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;_glob_dir: #{_glob_dir}\n&quot;</span>
        

        <span class="ruby-comment"># Go through directory to find all files</span>
        <span class="ruby-comment"># Create new array to hold all parsed files</span>
        <span class="ruby-identifier">_completed_files</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-constant">Dir</span>.<span class="ruby-identifier">glob</span>(<span class="ruby-node">&quot;#{ _glob_dir }{*,.*}&quot;</span>).<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span> <span class="ruby-identifier">_fn</span> <span class="ruby-operator">|</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">file?</span>(<span class="ruby-identifier">_fn</span>) }.<span class="ruby-identifier">sort</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_entry</span> <span class="ruby-operator">|</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Entry: #{_entry} is a file\n&quot;</span>  
        
        
                <span class="ruby-comment"># [review] - Warning to user when file is ignored? (outside of debug_print)</span>
                <span class="ruby-comment"># Check against ignore list, if match, set to &quot;&quot; which will be ignored</span>
                <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">ignore_list</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_ignore</span> <span class="ruby-operator">|</span>
                        <span class="ruby-comment"># [review] - Better &quot;Ruby&quot; way to check for &quot;*&quot;? </span>
                        <span class="ruby-comment"># [review] - Probably cleaner way to perform multiple checks below</span>
                        <span class="ruby-comment"># Look for *.type on list, regex to match entry</span>
                        <span class="ruby-keyword">if</span> <span class="ruby-identifier">_ignore</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-string">&quot;*&quot;</span>
                                <span class="ruby-identifier">_cut</span> = <span class="ruby-identifier">_ignore</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]
                                <span class="ruby-keyword">if</span> <span class="ruby-identifier">_entry</span>.<span class="ruby-identifier">match</span>(<span class="ruby-node">/#{ _cut }/</span>)
                                        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ _entry } is on the ignore list, setting to \&quot;\&quot;\n&quot;</span>
                                        <span class="ruby-identifier">_entry</span> = <span class="ruby-string">&quot;&quot;</span>
                                        <span class="ruby-keyword">break</span>
                                <span class="ruby-keyword">end</span>
                        <span class="ruby-comment"># Else check for verbose ignore match</span>
                        <span class="ruby-keyword">else</span>
                                <span class="ruby-keyword">if</span>  <span class="ruby-identifier">_entry</span>  <span class="ruby-operator">==</span> <span class="ruby-identifier">_ignore</span> <span class="ruby-operator">||</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">absolute_path</span>(<span class="ruby-identifier">_entry</span>) <span class="ruby-operator">==</span> <span class="ruby-identifier">_ignore</span>
                                        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ _entry } is on the ignore list, setting to \&quot;\&quot;\n&quot;</span>
                                        <span class="ruby-identifier">_entry</span> = <span class="ruby-string">&quot;&quot;</span>
                                        <span class="ruby-keyword">break</span>
                                <span class="ruby-keyword">end</span>
                        <span class="ruby-keyword">end</span>
                <span class="ruby-keyword">end</span> 

                <span class="ruby-comment"># If the resulting entry (after filtering) isn&#39;t empty, parse it and push into file array</span>
                <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">_entry</span>.<span class="ruby-identifier">empty?</span>
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Parsing #{ _entry }\n&quot;</span>
                        <span class="ruby-identifier">_completed_files</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">parse_file</span>(<span class="ruby-identifier">_entry</span>))
                <span class="ruby-keyword">end</span> 
        
        <span class="ruby-keyword">end</span>
                 
        
        <span class="ruby-comment"># Go through directory to find all subdirs</span>
        <span class="ruby-comment"># Create new array to hold all parsed subdirs </span>
        <span class="ruby-identifier">_completed_dirs</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-constant">Dir</span>.<span class="ruby-identifier">glob</span>(<span class="ruby-node">&quot;#{ _glob_dir }{*, .*}&quot;</span>).<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span> <span class="ruby-identifier">_fn</span> <span class="ruby-operator">|</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">directory?</span>(<span class="ruby-identifier">_fn</span>) }.<span class="ruby-identifier">sort</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_entry</span> <span class="ruby-operator">|</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Entry: #{ _entry } is a dir\n&quot;</span> 
                        
                

                <span class="ruby-comment">## Depth limit logic</span>
                <span class="ruby-comment"># Current depth is depth of previous parse_dir (passed in as second param) + 1</span>
                <span class="ruby-identifier">_cur_depth</span> = <span class="ruby-identifier">depth</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Current Folder depth: #{ _cur_depth }\n&quot;</span>
                
                <span class="ruby-comment"># If Config.parse_depth is 0, no limit on subdir parsing</span>
                <span class="ruby-keyword">if</span> <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">parse_depth</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;No max depth, parsing directory\n&quot;</span>
                        <span class="ruby-identifier">_completed_dirs</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">parse_dir</span>(<span class="ruby-node">&quot;#{ _entry }/&quot;</span>, <span class="ruby-identifier">_cur_depth</span>))
                <span class="ruby-comment"># If current depth is less than limit (set in config), parse directory and pass depth</span>
                <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">_cur_depth</span> <span class="ruby-operator">&lt;</span> <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">parse_depth</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;Depth less than max dept (from config), parsing directory\n&quot;</span>
                        <span class="ruby-identifier">_completed_dirs</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">parse_dir</span>(<span class="ruby-node">&quot;#{ _entry }/&quot;</span>, <span class="ruby-identifier">_cur_depth</span>))
                <span class="ruby-comment"># Else, depth is greater than limit, ignore the directory</span>
                <span class="ruby-keyword">else</span>
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;Depth greater than max depth, ignoring\n&quot;</span>     
                <span class="ruby-keyword">end</span>

                <span class="ruby-comment"># Add directory to ignore list so it isn&#39;t repeated again accidentally</span>
                <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">ignore_list</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">_entry</span>)
        <span class="ruby-keyword">end</span>


        <span class="ruby-comment"># [review] - Not sure if Dir.glob requires a explicit directory/file close?</span>
                
        <span class="ruby-comment"># Create hash to hold all parsed files and directories</span>
        <span class="ruby-identifier">_structure</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-identifier">_structure</span>[<span class="ruby-value">:curdir</span>] = <span class="ruby-identifier">dir</span>
        <span class="ruby-identifier">_structure</span>[<span class="ruby-value">:files</span>] = <span class="ruby-identifier">_completed_files</span>
        <span class="ruby-identifier">_structure</span>[<span class="ruby-value">:subdirs</span>]  = <span class="ruby-identifier">_completed_dirs</span>
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">_structure</span>
<span class="ruby-keyword">end</span></code></pre>
						</div>
										</div>

					
									</div>
								<a name="method-i-parse_file">anchor</a>
				<div id="method-i-parse_file-doc" class="method">

					<header>
											<i class="icon-generic"></i>
						<span class="method-name">parse_file</span><span 
							class="method-args">(filename)</span>
										</header>

					<div class="method-description">
											<p>Parse through individual files looking for issue tags, then generate
formatted issue hash</p>					
											<div class="method-source-code" id="parse_file-source">
							<pre class="prettyprint linenums"><code 
								class="language-ruby"><span class="ruby-comment"># File lib/watson/parser.rb, line 176</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">parse_file</span>(<span class="ruby-identifier">filename</span>)
<span class="ruby-comment"># [review] - Rename method input param to filename (more verbose?)</span>

        <span class="ruby-comment"># Identify method entry</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ self } : #{ __method__ }\n&quot;</span>

        <span class="ruby-identifier">_relative_path</span> = <span class="ruby-identifier">filename</span>
        <span class="ruby-identifier">_absolute_path</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">absolute_path</span>(<span class="ruby-identifier">filename</span>) 

        <span class="ruby-comment"># Error check on input, use input filename to make sure relative path is correct</span>
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-constant">Watson</span><span class="ruby-operator">::</span><span class="ruby-constant">FS</span>.<span class="ruby-identifier">check_file</span>(<span class="ruby-identifier">_relative_path</span>)
                <span class="ruby-identifier">print</span> <span class="ruby-node">&quot;Unable to open #{ _relative_path }, exiting\n&quot;</span>
                <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>
        <span class="ruby-keyword">else</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Opened #{ _relative_path } for parsing\n&quot;</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Short path: #{ _relative_path }\n&quot;</span>
        <span class="ruby-keyword">end</span>


        <span class="ruby-comment"># Get filetype and set corresponding comment type</span>
        <span class="ruby-identifier">_comment_type</span> = <span class="ruby-identifier">get_comment_type</span>(<span class="ruby-identifier">_relative_path</span>)
        <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">_comment_type</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Using default (#) comment type\n&quot;</span>
                <span class="ruby-identifier">_comment_type</span> = <span class="ruby-node">&quot;#&quot;</span>
        <span class="ruby-keyword">end</span>


        <span class="ruby-comment"># Open file and read in entire thing into an array</span>
        <span class="ruby-comment"># Use an array so we can look ahead when creating issues later</span>
        <span class="ruby-comment"># [review] - Not sure if explicit file close is required here</span>
        <span class="ruby-comment"># [review] - Better var name than data for read in file?</span>
        <span class="ruby-identifier">_data</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-identifier">_absolute_path</span>, <span class="ruby-string">&#39;r&#39;</span>).<span class="ruby-identifier">read</span>.<span class="ruby-identifier">each_line</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_line</span> <span class="ruby-operator">|</span>
                <span class="ruby-identifier">_data</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">_line</span>)
        <span class="ruby-keyword">end</span>

        
        <span class="ruby-comment"># Initialize issue list hash </span>
        <span class="ruby-identifier">_issue_list</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-identifier">_issue_list</span>[<span class="ruby-value">:relative_path</span>] = <span class="ruby-identifier">_relative_path</span> 
        <span class="ruby-identifier">_issue_list</span>[<span class="ruby-value">:absolute_path</span>] = <span class="ruby-identifier">_absolute_path</span>
        <span class="ruby-identifier">_issue_list</span>[<span class="ruby-value">:has_issues</span>] = <span class="ruby-keyword">false</span>
        <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">tag_list</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_tag</span> <span class="ruby-operator">|</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Creating array named #{ _tag }\n&quot;</span>
                <span class="ruby-comment"># [review] - Use to_sym to make tag into symbol instead of string?</span>
                <span class="ruby-identifier">_issue_list</span>[<span class="ruby-identifier">_tag</span>] = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>
        <span class="ruby-keyword">end</span>
        
        <span class="ruby-comment"># Loop through all array elements (lines in file) and look for issues</span>
        <span class="ruby-identifier">_data</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_line</span>, <span class="ruby-identifier">_i</span> <span class="ruby-operator">|</span>

                <span class="ruby-comment"># Find any comment line with [tag] - text (any comb of space and # acceptable)</span>
                <span class="ruby-comment"># Using if match to stay consistent (with config.rb) see there for</span>
                <span class="ruby-comment"># explanation of why I do this (not a good good one persay...)</span>
                <span class="ruby-identifier">_mtch</span> = <span class="ruby-identifier">_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-node">/^[#{ _comment_type }+?\s+?]+\[(\w+)\]\s+-\s+(.+)/</span>)
                <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">_mtch</span>
                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;No valid tag found in line, skipping\n&quot;</span>
                        <span class="ruby-keyword">next</span>
                <span class="ruby-keyword">end</span>
        
                <span class="ruby-comment"># Set tag</span>
                <span class="ruby-identifier">_tag</span> = <span class="ruby-identifier">_mtch</span>[<span class="ruby-value">1</span>]

                <span class="ruby-comment"># Make sure that the tag that was found is something we accept</span>
                <span class="ruby-comment"># If not, skip it but tell user about an unrecognized tag</span>
                <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-ivar">@config</span>.<span class="ruby-identifier">tag_list</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">_tag</span>)
                        <span class="ruby-constant">Printer</span>.<span class="ruby-identifier">print_status</span> <span class="ruby-string">&quot;!&quot;</span>, <span class="ruby-constant">RED</span>
                        <span class="ruby-identifier">print</span> <span class="ruby-node">&quot;Unknown tag [#{ _tag }] found, ignoring\n&quot;</span>
                        <span class="ruby-identifier">print</span> <span class="ruby-string">&quot;      You might want to include it in your RC or with the -t/--tags flag\n&quot;</span>
                        <span class="ruby-keyword">next</span>
                <span class="ruby-keyword">end</span>

                <span class="ruby-comment"># Found a valid match (with recognized tag)</span>
                <span class="ruby-comment"># Set flag for this issue_list (for file) to indicate that</span>
                <span class="ruby-identifier">_issue_list</span>[<span class="ruby-value">:has_issues</span>] = <span class="ruby-keyword">true</span>

                <span class="ruby-identifier">_title</span> = <span class="ruby-identifier">_mtch</span>[<span class="ruby-value">2</span>]
                <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;Issue found\n&quot;</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Tag: #{ _tag }\n&quot;</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Issue: #{ _title }\n&quot;</span>  

                <span class="ruby-comment"># Create hash for each issue found</span>
                <span class="ruby-identifier">_issue</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>
                <span class="ruby-identifier">_issue</span>[<span class="ruby-value">:line_number</span>] = <span class="ruby-identifier">_i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
                <span class="ruby-identifier">_issue</span>[<span class="ruby-value">:title</span>] = <span class="ruby-identifier">_title</span>

                <span class="ruby-comment"># Grab context of issue specified by Config param (+1 to include issue itself)</span>
                <span class="ruby-identifier">_context</span> = <span class="ruby-identifier">_data</span>[<span class="ruby-identifier">_i</span><span class="ruby-operator">..</span>(<span class="ruby-identifier">_i</span> <span class="ruby-operator">+</span> <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">context_depth</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>)]

                <span class="ruby-comment"># [review] - There has got to be a better way to do this... </span>
                <span class="ruby-comment"># Go through each line of context and determine indentation</span>
                <span class="ruby-comment"># Used to preserve indentation in post</span>
                <span class="ruby-identifier">_cut</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span> 
                <span class="ruby-identifier">_context</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_line</span> <span class="ruby-operator">|</span>
                        <span class="ruby-identifier">_max</span> = <span class="ruby-value">0</span>
                        <span class="ruby-comment"># Until we reach a non indent OR the line is empty, keep slicin&#39;</span>
                        <span class="ruby-keyword">until</span> <span class="ruby-operator">!</span><span class="ruby-identifier">_line</span>.<span class="ruby-identifier">match</span>(<span class="ruby-regexp">/^( |\t|\n)/</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">_line</span>.<span class="ruby-identifier">empty?</span>
                                <span class="ruby-comment"># [fix] - Replace with inplace slice!</span>
                                <span class="ruby-identifier">_line</span> = <span class="ruby-identifier">_line</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>)
                                <span class="ruby-identifier">_max</span> = <span class="ruby-identifier">_max</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>

                                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;New line: #{ _line }\n&quot;</span>
                                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;Max indent: #{ _max }\n&quot;</span>
                        <span class="ruby-keyword">end</span>
                        
                        <span class="ruby-comment"># Push max indent for current line to the _cut array </span>
                        <span class="ruby-identifier">_cut</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">_max</span>)    
                <span class="ruby-keyword">end</span> 
        
                <span class="ruby-comment"># Print old _context</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;\n\n Old Context \n&quot;</span>
                <span class="ruby-identifier">debug_print</span> <span class="ruby-constant">PP</span>.<span class="ruby-identifier">pp</span>(<span class="ruby-identifier">_context</span>, <span class="ruby-string">&quot;&quot;</span>)
                <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;\n\n&quot;</span>

                <span class="ruby-comment"># Trim the context lines to be left aligned but maintain indentation</span>
                <span class="ruby-comment"># Then add a single \t to the beginning so the Markdown is pretty on GitHub/Bitbucket</span>
                <span class="ruby-identifier">_context</span>.<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span> <span class="ruby-identifier">_line</span> <span class="ruby-operator">|</span> <span class="ruby-node">&quot;\t#{ _line.slice(_cut.min .. -1) }&quot;</span> }
        
                <span class="ruby-comment"># Print new _context        </span>
                <span class="ruby-identifier">debug_print</span>(<span class="ruby-string">&quot;\n\n New Context \n&quot;</span>)
                <span class="ruby-identifier">debug_print</span> <span class="ruby-constant">PP</span>.<span class="ruby-identifier">pp</span>(<span class="ruby-identifier">_context</span>, <span class="ruby-string">&quot;&quot;</span>)
                <span class="ruby-identifier">debug_print</span>(<span class="ruby-string">&quot;\n\n&quot;</span>)

                <span class="ruby-identifier">_issue</span>[<span class="ruby-value">:context</span>] = <span class="ruby-identifier">_context</span>
                        
                <span class="ruby-comment"># These are accessible from _issue_list, but we pass individual issues</span>
                <span class="ruby-comment"># to the remote poster, so we need this here to reference them for GitHub/Bitbucket</span>
                <span class="ruby-identifier">_issue</span>[<span class="ruby-value">:tag</span>] = <span class="ruby-identifier">_tag</span>
                <span class="ruby-identifier">_issue</span>[<span class="ruby-value">:path</span>] = <span class="ruby-identifier">_relative_path</span> 

                <span class="ruby-comment"># Generate md5 hash for each specific issue (for bookkeeping)</span>
                <span class="ruby-identifier">_issue</span>[<span class="ruby-value">:md5</span>] = <span class="ruby-operator">::</span><span class="ruby-constant">Digest</span><span class="ruby-operator">::</span><span class="ruby-constant">MD5</span>.<span class="ruby-identifier">hexdigest</span>(<span class="ruby-node">&quot;#{ _tag }, #{ _relative_path }, #{ _title }&quot;</span>)
                <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ _issue }\n&quot;</span>


                <span class="ruby-comment"># [todo] - Figure out a way to queue up posts so user has a progress bar?</span>
                <span class="ruby-comment"># That way user can tell that wait is because of http calls not app</span>
        
                <span class="ruby-comment"># If GitHub is valid, pass _issue to GitHub poster function</span>
                <span class="ruby-comment"># [review] - Keep Remote as a static method and pass config every time?</span>
                <span class="ruby-comment">#                    Or convert to a regular class and make an instance with @config</span>

                        <span class="ruby-keyword">if</span> <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">remote_valid</span>
                                <span class="ruby-keyword">if</span> <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">github_valid</span>
                                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;GitHub is valid, posting issue\n&quot;</span>
                                        <span class="ruby-constant">Remote</span><span class="ruby-operator">::</span><span class="ruby-constant">GitHub</span>.<span class="ruby-identifier">post_issue</span>(<span class="ruby-identifier">_issue</span>, <span class="ruby-ivar">@config</span>)
                                <span class="ruby-keyword">else</span>
                                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;GitHub invalid, not posting issue\n&quot;</span>
                                <span class="ruby-keyword">end</span>       


                                <span class="ruby-keyword">if</span> <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">bitbucket_valid</span>
                                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;Bitbucket is valid, posting issue\n&quot;</span>
                                        <span class="ruby-constant">Remote</span><span class="ruby-operator">::</span><span class="ruby-constant">Bitbucket</span>.<span class="ruby-identifier">post_issue</span>(<span class="ruby-identifier">_issue</span>, <span class="ruby-ivar">@config</span>)
                                <span class="ruby-keyword">else</span>
                                        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;Bitbucket invalid, not posting issue\n&quot;</span>
                                <span class="ruby-keyword">end</span>
                        <span class="ruby-keyword">end</span>
        
                        <span class="ruby-comment"># [review] - Use _tag string as symbol reference in hash or keep as string?</span>
                        <span class="ruby-comment"># Look into to_sym to keep format of all _issue params the same</span>
                        <span class="ruby-identifier">_issue_list</span>[<span class="ruby-identifier">_tag</span>].<span class="ruby-identifier">push</span>( <span class="ruby-identifier">_issue</span> )

        <span class="ruby-keyword">end</span>

        <span class="ruby-comment"># [review] - Return of parse_file is different than watson-perl</span>
        <span class="ruby-comment"># Not sure which makes more sense, ruby version seems simpler</span>
        <span class="ruby-comment"># perl version might have to stay since hash scoping is weird in perl</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;\nIssue list: #{ _issue_list }\n&quot;</span>

        <span class="ruby-keyword">return</span> <span class="ruby-identifier">_issue_list</span>
<span class="ruby-keyword">end</span></code></pre>
						</div>
										</div>

					
									</div>
								<a name="method-i-run">anchor</a>
				<div id="method-i-run-doc" class="method">

					<header>
											<i class="icon-generic"></i>
						<span class="method-name">run</span><span 
							class="method-args">()</span>
										</header>

					<div class="method-description">
											<p>Begins parsing of files / dirs specified in the initial dir/file lists</p>					
											<div class="method-source-code" id="run-source">
							<pre class="prettyprint linenums"><code 
								class="language-ruby"><span class="ruby-comment"># File lib/watson/parser.rb, line 32</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">run</span>

        <span class="ruby-comment"># Identify method entry</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-node">&quot;#{ self } : #{ __method__ }\n&quot;</span>
        
        <span class="ruby-comment"># Go through all files added from CL (sort them first)</span>
        <span class="ruby-comment"># If empty, sort and each will do nothing, no errors</span>
        <span class="ruby-identifier">_completed_dirs</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-identifier">_completed_files</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-keyword">if</span> <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">cl_entry_set</span>
                <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">file_list</span>.<span class="ruby-identifier">sort</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_file</span> <span class="ruby-operator">|</span>
                        <span class="ruby-identifier">_completed_files</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">parse_file</span>(<span class="ruby-identifier">_file</span>))
                <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>
        
        <span class="ruby-comment"># Then go through all the specified directories </span>
        <span class="ruby-comment"># Initial parse depth to parse_dir is 0 (unlimited)</span>
        <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">dir_list</span>.<span class="ruby-identifier">sort</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">_dir</span> <span class="ruby-operator">|</span>
                <span class="ruby-identifier">_completed_dirs</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">parse_dir</span>(<span class="ruby-identifier">_dir</span>, <span class="ruby-value">0</span>))
        <span class="ruby-keyword">end</span>  
        
        <span class="ruby-comment"># Create overall hash for parsed files       </span>
        <span class="ruby-identifier">_structure</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>()
        <span class="ruby-identifier">_structure</span>[<span class="ruby-value">:files</span>] = <span class="ruby-identifier">_completed_files</span>
        <span class="ruby-identifier">_structure</span>[<span class="ruby-value">:subdirs</span>]  = <span class="ruby-identifier">_completed_dirs</span>

        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;_structure dump\n\n&quot;</span>
        <span class="ruby-identifier">debug_print</span> <span class="ruby-constant">PP</span>.<span class="ruby-identifier">pp</span>(<span class="ruby-identifier">_structure</span>, <span class="ruby-string">&quot;&quot;</span>)
        <span class="ruby-identifier">debug_print</span> <span class="ruby-string">&quot;\n\n&quot;</span>
        
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">_structure</span>
<span class="ruby-keyword">end</span></code></pre>
						</div>
										</div>

					
									</div>
				
			</section>
			
			
			
			
			
						
		</section>
		

		<hr>

		<footer>
			<div class="container">
				<span id="rdoc-version">Generated by RDoc 4.0.1</span> using the
				<a id="generator-version"
					href="http://deveiate.org/fivefish">Fivefish RDoc 0.1.0</a> generator.
			</div>
		</footer>
	</div> <!-- /container -->

	<!-- Class dropdown menu -->
	<div id="class-dropdown" class="dropdown-menu has-scroll">
	<ul>
			<li><a href="../Watson.html">Watson</a></li>
			<li><a href="../Watson/Command.html">Watson::Command</a></li>
			<li><a href="../Watson/Config.html">Watson::Config</a></li>
			<li><a href="../Watson/FS.html">Watson::FS</a></li>
			<li><a href="../Watson/Parser.html">Watson::Parser</a></li>
			<li><a href="../Watson/Printer.html">Watson::Printer</a></li>
			<li><a href="../Watson/Remote.html">Watson::Remote</a></li>
			<li><a href="../Watson/Remote/Bitbucket.html">Watson::Remote::Bitbucket</a></li>
			<li><a href="../Watson/Remote/GitHub.html">Watson::Remote::GitHub</a></li>
		</ul>
	</div>

	<!-- File dropdown menu -->
	<div id="file-dropdown" class="dropdown-menu has-scroll">
	<ul>
		</ul>
	</div>

</body>
</html>
